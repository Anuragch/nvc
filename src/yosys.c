//
//  Copyright (C) 2016  Nick Gasson
//
//  This program is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program.  If not, see <http://www.gnu.org/licenses/>.
//

#include "util.h"
#include "phase.h"
#include "yosys.h"

#include <assert.h>
#include <stdarg.h>
#include <stdio.h>

static yosys_cmd_fn_t cmd_fn;
static void          *cmd_context;

static void yosys_printer_fn(const yosys_cmd_t *cmd, void *context)
{
   FILE *f = context;

   switch (cmd->kind) {
   case YOSYS_COMMENT:
      fprintf(f, "# %s\n", cmd->comment);
      break;
   case YOSYS_LOCATION:
      fprintf(f, "attribute \\src \"%s:%d\"\n",
              cmd->location.file, cmd->location.first_line);
      break;
   case YOSYS_BEGIN_MODULE:
      fprintf(f, "module \\%s\n", istr(cmd->begin_module));
      break;
   case YOSYS_END_MODULE:
      fprintf(f, "end\n");
      break;
   case YOSYS_WIRE:
      fprintf(f, "wire \\%s\n", istr(cmd->wire));
      break;
   }
}

static void emit_comment(const char *fmt, ...)
{
   va_list ap;
   va_start(ap, fmt);
   char *buf LOCAL = xvasprintf(fmt, ap);
   va_end(ap);

   const yosys_cmd_t cmd = {
      .kind = YOSYS_COMMENT,
      .comment = buf
   };
   (*cmd_fn)(&cmd, cmd_context);
}

static void emit_location(const loc_t *loc)
{
   const yosys_cmd_t cmd = {
      .kind = YOSYS_LOCATION,
      .location = *loc
   };
   (*cmd_fn)(&cmd, cmd_context);
}

static void begin_module(ident_t name)
{
   const yosys_cmd_t cmd = {
      .kind = YOSYS_BEGIN_MODULE,
      .begin_module = name
   };
   (*cmd_fn)(&cmd, cmd_context);
}

static void end_module(void)
{
   const yosys_cmd_t cmd = {
      .kind = YOSYS_END_MODULE
   };
   (*cmd_fn)(&cmd, cmd_context);
}

static void emit_wire(ident_t name)
{
   const yosys_cmd_t cmd = {
      .kind = YOSYS_WIRE,
      .wire = name
   };
   (*cmd_fn)(&cmd, cmd_context);
}

static void synth_signal_decl(tree_t decl)
{
   emit_wire(tree_ident(decl));
}

static void synth_decl(tree_t decl)
{
   switch (tree_kind(decl)) {
   case T_SIGNAL_DECL:
      synth_signal_decl(decl);
      break;
   case T_HIER:
      break;
   default:
      fatal_at(tree_loc(decl), "cannot synthesise %s",
               tree_kind_str(tree_kind(decl)));
   }
}

void synth(tree_t top)
{
   assert(tree_kind(top) == T_ELAB);

   if (cmd_fn == NULL)
      set_yosys_cmd_fn(yosys_printer_fn, stdout);

   dump(top);

   emit_comment("%s", "Generated by " PACKAGE_STRING);
   emit_location(tree_loc(top));
   begin_module(ident_strip(tree_ident(top), ident_new(".elab")));

   const int ndecls = tree_decls(top);
   for (int i = 0; i < ndecls; i++)
      synth_decl(tree_decl(top, i));

   end_module();
}

void set_yosys_cmd_fn(yosys_cmd_fn_t fn, void *context)
{
   cmd_fn = fn;
   cmd_context = context;
}
